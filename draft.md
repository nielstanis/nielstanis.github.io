---
layout: post
title: Sandboxing and isolating .NET assemblies
categories: [sandbox]
tags: [csharp, dotnet, wasm, wasi]
---

Earlier this week Steve Sanderson of Microsoft shared a very interesting experimental project called [DotnetIsolator](https://github.com/SteveSandersonMS/DotNetIsolator/tree/main/src/DotNetIsolator){:target="_blank"}, and once I saw the demo's he created for it I got exited. The projects allows you to run code inside an isolated environment in a pretty easy way. I realized that this project is like an intersection of two projects I've been working and presenting on for the last four years. The thing that eventually struck me most is the ease with how it got integrated and that's a thing I've not solved in my own .NET sandbox approach yet. I thought this was a good moment to share some on my thoughts on this and start this blog-post. 

# Why sandboxing .NET assemblies?

In modern software development there are several metrics that show out that 80% of our code base consists of libraries/code that is created by someone else or third party. And from productive perspective that totally makes sense, I always give the example to be _lazy_ as well and why not re-use something that's already there? If you write something fully from scratch yourself you probably also run into the same problems that others have already solved by writing it before you did. One down side which comes with that is the fact you put a lot of _trust_ into that used third party library or code and on top of that, do you always a have a clear view on what's inside and what you expect from that library? If it's widely used the odds will be high there might be a vulnerability found and hopefully fixed, and you need to keep it up-to-date for that matter as well. And what about libraries that have been taken over by people with bad intent? Maybe someone has compromised on of the parts inside the libraries supply chain and added some malware like e.g. a backdoor or crypto-locker. 

By default any library used in a .NET application will have the exact same access to the system resources as the process that started it out. And keep in mind that there might be even transitive dependencies you're initially not fully aware of that are part of it as well. And of course it might be a solution to create a separate limited process and host a component/library in that context and do some inter-process communication (or IPC) in between, similar as how a modern browser will do it. But that will mean some overhead and it would be better to have a solution that will keep it in a single process. 